/* Autogenerated by /usr/bin/halcompile on Mon May  5 21:29:21 2025 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "stdio.h"
#include "rtapi_math64.h"
#include "PoKeysLibHal.h"
#include "PoKeysLibAsync.h"

static int comp_id;


#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:pokeys:PoKeys HAL driver with PulseEngine v2 support");
MODULE_INFO(linuxcnc, "pin:in-#:bit:55:out::None:None");
MODULE_INFO(linuxcnc, "pin:ain-#:u32:3:out::None:None");
MODULE_INFO(linuxcnc, "pin:err:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:devSerial:u32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:alive:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *in[55];
    hal_u32_t *ain[3];
    hal_bit_t *err;
    hal_u32_t *devSerial;
    hal_bit_t *alive;

    sPoKeysDevice *dev;
    
    // PulseEngine v2 HAL interface - exact userspace compatibility
    struct {
        // Motion control pins - CRITICAL for LinuxCNC
        hal_float_t *joint_pos_cmd[8];     // pokeys.0.PEv2.0.joint-pos-cmd
        hal_float_t *joint_vel_cmd[8];     // pokeys.0.PEv2.0.joint-vel-cmd  
        hal_float_t *joint_pos_fb[8];      // pokeys.0.PEv2.0.joint-pos-fb
        hal_bit_t *joint_in_position[8];   // pokeys.0.PEv2.0.joint-in-position
        
        // PEv2 state pins - exact userspace match
        hal_u32_t *PEv2_AxesState[8];      // pokeys.0.PEv2.0.AxesState
        hal_u32_t *PEv2_AxesCommand[8];    // pokeys.0.PEv2.0.AxesCommand
        hal_s32_t *PEv2_CurrentPosition[8]; // pokeys.0.PEv2.0.CurrentPosition
        
        // Device info pins
        hal_u32_t *PEv2_nrOfAxes;          // pokeys.0.PEv2.nrOfAxes
        hal_u32_t *PEv2_maxPulseFrequency; // pokeys.0.PEv2.maxPulseFrequency
        hal_u32_t *PEv2_bufferDepth;       // pokeys.0.PEv2.bufferDepth
        hal_u32_t *PEv2_slotTiming;        // pokeys.0.PEv2.slotTiming
        
        // Engine state pins
        hal_u32_t *PEv2_PulseEngineActivated; // pokeys.0.PEv2.PulseEngineActivated
        hal_u32_t *PEv2_PulseEngineState;     // pokeys.0.PEv2.PulseEngineState
        
        // Emergency and safety pins
        hal_bit_t *PEv2_digin_Emergency_in;     // pokeys.0.PEv2.digin.Emergency.in
        hal_bit_t *PEv2_digin_Emergency_in_not; // pokeys.0.PEv2.digin.Emergency.in-not
        hal_bit_t *PEv2_digout_Emergency_out;   // pokeys.0.PEv2.digout.Emergency.out
        
        // Limit switch pins per axis
        hal_bit_t *PEv2_digin_LimitN_in[8];     // pokeys.0.PEv2.0.digin.LimitN.in
        hal_bit_t *PEv2_digin_LimitN_in_not[8]; // pokeys.0.PEv2.0.digin.LimitN.in-not
        hal_bit_t *PEv2_digin_LimitP_in[8];     // pokeys.0.PEv2.0.digin.LimitP.in
        hal_bit_t *PEv2_digin_LimitP_in_not[8]; // pokeys.0.PEv2.0.digin.LimitP.in-not
        hal_bit_t *PEv2_digin_Home_in[8];       // pokeys.0.PEv2.0.digin.Home.in
        hal_bit_t *PEv2_digin_Home_in_not[8];   // pokeys.0.PEv2.0.digin.Home.in-not
        
        // Homing pins
        hal_u32_t *PEv2_HomingStatus[8];        // pokeys.0.PEv2.0.HomingStatus
        hal_bit_t *PEv2_index_enable[8];        // pokeys.0.PEv2.0.index-enable
        
        // External outputs
        hal_bit_t *PEv2_digout_ExternalRelay_out[4]; // pokeys.0.PEv2.digout.ExternalRelay-0.out
        hal_bit_t *PEv2_digout_ExternalOC_out[4];    // pokeys.0.PEv2.digout.ExternalOC-0.out
        hal_u32_t *PEv2_ExternalRelayOutputs;        // pokeys.0.PEv2.ExternalRelayOutputs
        hal_u32_t *PEv2_ExternalOCOutputs;           // pokeys.0.PEv2.ExternalOCOutputs
        
        // Probing pins
        hal_u32_t *PEv2_ProbePosition[8];       // pokeys.0.PEv2.0.ProbePosition
        hal_u32_t *PEv2_ProbeMaxPosition[8];    // pokeys.0.PEv2.0.ProbeMaxPosition
        hal_u32_t *PEv2_ProbeStatus;            // pokeys.0.PEv2.ProbeStatus
        hal_bit_t *PEv2_digin_Probed_in;        // pokeys.0.PEv2.digin.Probed.in
        
        // MPG jogging pins
        hal_bit_t *PEv2_joint_kb_jog_active[8];     // pokeys.0.PEv2.0.joint-kb-jog-active
        hal_bit_t *PEv2_joint_wheel_jog_active[8];  // pokeys.0.PEv2.0.joint-wheel-jog-active
        
        // Parameters (not HAL pins, stored directly)
        hal_float_t PEv2_MaxSpeed[8];
        hal_float_t PEv2_MaxAcceleration[8];
        hal_s32_t PEv2_home_sequence[8];
        hal_float_t PEv2_stepgen_STEP_SCALE[8];
        hal_s32_t PEv2_PositionScale[8];
        hal_s32_t PEv2_PositionOffset[8];
    } pev2_data;
};

#include <stdlib.h>
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
uint32_t device_id = 0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);

    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: exporting component - extra_setup %s\n", __FILE__, __FUNCTION__, prefix);
    r = extra_setup(inst, prefix, extra_arg);
    if (r != 0){
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: extra_setup failed\n", __FILE__, __FUNCTION__);
        return r;
    }
    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: exporting component - export_rtc_pins %s\n", __FILE__, __FUNCTION__, prefix);
    r = export_rtc_pins(prefix, comp_id, inst->dev); // Export RTC pins
    if(r != 0){
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: export_rtc_pins faile %d \n", __FILE__, __FUNCTION__, prefix, r);
        return r;
    };
    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: exporting component - export_encoder_pins %s\n", __FILE__, __FUNCTION__, prefix);
    r=export_encoder_pins(prefix, comp_id, inst->dev); // Export encoder pins
    if(r != 0){
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: export_encoder_pins failed %d \n", __FILE__, __FUNCTION__, prefix, r);
        return r;
    };
    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: exporting component - export_IO_pins %s\n", __FILE__, __FUNCTION__, prefix);
    r=export_IO_pins(prefix, comp_id, inst->dev); // Export IO pins
    if(r != 0){
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: export_IO_pins failed %d \n", __FILE__, __FUNCTION__, prefix, r);
        return r;
    };
    
    // Export PEv2 HAL pins - NEW
    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: exporting component - export_pev2_hal_pins %s\n", __FILE__, __FUNCTION__, prefix);
    r = export_pev2_hal_pins(inst, prefix, comp_id);
    if(r != 0){
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: export_pev2_hal_pins failed %d \n", __FILE__, __FUNCTION__, r);
        return r;
    };

#ifdef RTAPI
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
#endif
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
#ifdef RTAPI
RTAPI_MP_INT(count, "number of pokeys_async");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of pokeys_async");
#else
char *names[16] = {0,};
#endif
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("pokeys_async");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "pokeys-async.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
#ifdef RTAPI
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
#else
        int max_names = sizeof(names)/sizeof(names[0]);
        for(i=0; (i < max_names) && names[i]; i++) {
            if (strlen(names[i]) < 1) {
                rtapi_print_msg(RTAPI_MSG_ERR, "names[%d] is invalid (empty string)\n", i);

                r = -EINVAL;
                break;
            }
            r = export(names[i], i);
            if(r != 0) break;
#endif

       }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}
#ifndef RTAPI
static void user_mainloop(void);

int __comp_parse_count(int *argc, char **argv) {
    int i;
    for (i = 0; i < *argc; i ++) {
        if (strncmp(argv[i], "count=", 6) == 0) {
            errno = 0;
            count = strtoul(&argv[i][6], NULL, 0);
            for (; i+1 < *argc; i ++) {
                argv[i] = argv[i+1];
            }
            argv[i] = NULL;
            (*argc)--;
            if (errno == 0) {
                return 1;
            }
        }
    }
    return 0;
}


int __comp_parse_names(int *argc, char **argv) {
    int i;
    for (i = 0; i < *argc; i ++) {
        if (strncmp(argv[i], "names=", 6) == 0) {
            char *p = &argv[i][6];
            int j;
            for (; i+1 < *argc; i ++) {
                argv[i] = argv[i+1];
            }
            argv[i] = NULL;
            (*argc)--;
            for (j = 0; j < 16; j ++) {
                names[j] = strtok(p, ",");
                p = NULL;
                if (names[j] == NULL) {
                    return 1;
                }
            }
            return 1;
        }
    }
    return 0;
}

int argc=0; char **argv=0;
int main(int argc_, char **argv_) {
    argc = argc_; argv = argv_;
    int found_count, found_names;
    found_count = __comp_parse_count(&argc, argv);
    found_names = __comp_parse_names(&argc, argv);
    if (found_count && found_names) {
        rtapi_print_msg(RTAPI_MSG_ERR, "count= and names= are mutually exclusive\n");
        return 1;
    }

    if(rtapi_app_main() < 0) return 1;
    user_mainloop();
    rtapi_app_exit();
    return 0;
}
#endif

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef in
#define in(i) (*(__comp_inst->in[i]))
#undef ain
#define ain(i) (*(__comp_inst->ain[i]))
#undef err
#define err (*__comp_inst->err)
#undef devSerial
#define devSerial (0+*__comp_inst->devSerial)
#undef alive
#define alive (*__comp_inst->alive)
#undef FOR_ALL_INSTS
#define FOR_ALL_INSTS() struct __comp_state *__comp_inst; for(__comp_inst = __comp_first_inst; __comp_inst; __comp_inst = __comp_inst->_next)

// RT-safe motion data structures
typedef struct {
    volatile float pos_cmd[8];
    volatile float vel_cmd[8];
    volatile bool pos_cmd_changed[8];
    volatile bool vel_cmd_changed[8];
    
    // Cached feedback from device
    volatile float pos_fb[8];
    volatile bool in_position[8];
    volatile uint32_t axis_state[8];
    volatile int32_t current_position[8];
} rt_motion_data_t;

// Async command queue system
typedef enum {
    CMD_MOVE_PV,
    CMD_HOME_START,
    CMD_PROBE_START,
    CMD_EMERGENCY_STOP,
    CMD_EXTERNAL_OUTPUT_SET
} async_cmd_type_t;

typedef struct {
    async_cmd_type_t type;
    uint8_t axis_mask;
    float pos_values[8];
    float vel_values[8];
    uint32_t misc_data;
    bool processed;
} async_command_t;

#define MAX_ASYNC_COMMANDS 32
typedef struct {
    async_command_t commands[MAX_ASYNC_COMMANDS];
    volatile int head, tail;
    volatile int count;
} async_command_queue_t;

// Device status cache for RT-safe access
typedef struct {
    volatile uint32_t pulse_engine_state;
    volatile uint32_t axes_state[8];
    volatile int32_t current_position[8];
    volatile uint8_t limit_status_p;
    volatile uint8_t limit_status_n;
    volatile uint8_t home_status;
    volatile bool emergency_active;
    volatile uint32_t last_update_time;
    volatile bool communication_ok;
} device_status_cache_t;

// Global data structures
static rt_motion_data_t motion_data;
static async_command_queue_t cmd_queue = {0};
static device_status_cache_t device_cache = {0};

// Thread control
static bool async_processing_enabled = false;

// Async command queue functions
static bool enqueue_async_command(const async_command_t *cmd) {
    if (cmd_queue.count >= MAX_ASYNC_COMMANDS) {
        rtapi_print_msg(RTAPI_MSG_WARN, "PoKeys: Async command queue full\n");
        return false;
    }
    
    cmd_queue.commands[cmd_queue.head] = *cmd;
    cmd_queue.commands[cmd_queue.head].processed = false;
    cmd_queue.head = (cmd_queue.head + 1) % MAX_ASYNC_COMMANDS;
    __atomic_fetch_add(&cmd_queue.count, 1, __ATOMIC_SEQ_CST);
    return true;
}

static bool dequeue_async_command(async_command_t *cmd) {
    if (cmd_queue.count <= 0) return false;
    
    *cmd = cmd_queue.commands[cmd_queue.tail];
    cmd_queue.tail = (cmd_queue.tail + 1) % MAX_ASYNC_COMMANDS;
    __atomic_fetch_sub(&cmd_queue.count, 1, __ATOMIC_SEQ_CST);
    return true;
}

static bool queue_move_pv_command(uint8_t axis_mask, const float *positions, const float *velocities) {
    async_command_t cmd = {
        .type = CMD_MOVE_PV,
        .axis_mask = axis_mask
    };
    for (int i = 0; i < 8; i++) {
        cmd.pos_values[i] = positions[i];
        cmd.vel_values[i] = velocities[i];
    }
    return enqueue_async_command(&cmd);
}

static bool queue_homing_start_command(uint8_t axis_mask) {
    async_command_t cmd = {
        .type = CMD_HOME_START,
        .axis_mask = axis_mask
    };
    return enqueue_async_command(&cmd);
}

// Forward declarations for RT processing functions
static void rt_read_command_pins(struct __comp_state *inst);
static void rt_update_motion_commands(struct __comp_state *inst);
static void rt_read_device_cache(struct __comp_state *inst);
static void rt_handle_homing_commands(struct __comp_state *inst);
static void rt_update_external_outputs(struct __comp_state *inst);

// PEv2 HAL pin export function
int export_pev2_hal_pins(struct __comp_state *inst, char *prefix, int comp_id) {
    int r = 0;
    
    rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: Exporting PEv2 HAL pins with prefix %s\n", prefix);
    
    // Motion control pins - CRITICAL for LinuxCNC compatibility
    for (int i = 0; i < 8; i++) {
        r |= hal_pin_float_newf(HAL_IN, &inst->pev2_data.joint_pos_cmd[i], comp_id, 
                               "%s.PEv2.%01d.joint-pos-cmd", prefix, i);
        r |= hal_pin_float_newf(HAL_IN, &inst->pev2_data.joint_vel_cmd[i], comp_id, 
                               "%s.PEv2.%01d.joint-vel-cmd", prefix, i);
        r |= hal_pin_float_newf(HAL_OUT, &inst->pev2_data.joint_pos_fb[i], comp_id, 
                               "%s.PEv2.%01d.joint-pos-fb", prefix, i);
        r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.joint_in_position[i], comp_id, 
                             "%s.PEv2.%01d.joint-in-position", prefix, i);
        
        if (r != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Failed to export motion pins for axis %d\n", i);
            return r;
        }
    }
    
    // State and command pins
    for (int i = 0; i < 8; i++) {
        r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_AxesState[i], comp_id,
                             "%s.PEv2.%01d.AxesState", prefix, i);
        r |= hal_pin_u32_newf(HAL_IN, &inst->pev2_data.PEv2_AxesCommand[i], comp_id,
                             "%s.PEv2.%01d.AxesCommand", prefix, i);
        r |= hal_pin_s32_newf(HAL_OUT, &inst->pev2_data.PEv2_CurrentPosition[i], comp_id,
                             "%s.PEv2.%01d.CurrentPosition", prefix, i);
        
        if (r != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Failed to export state pins for axis %d\n", i);
            return r;
        }
    }
    
    // Device info pins
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_nrOfAxes, comp_id,
                         "%s.PEv2.nrOfAxes", prefix);
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_maxPulseFrequency, comp_id,
                         "%s.PEv2.maxPulseFrequency", prefix);
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_bufferDepth, comp_id,
                         "%s.PEv2.bufferDepth", prefix);
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_slotTiming, comp_id,
                         "%s.PEv2.slotTiming", prefix);
    
    // Engine state pins
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_PulseEngineActivated, comp_id,
                         "%s.PEv2.PulseEngineActivated", prefix);
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_PulseEngineState, comp_id,
                         "%s.PEv2.PulseEngineState", prefix);
    
    // Emergency and safety pins
    r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_Emergency_in, comp_id,
                         "%s.PEv2.digin.Emergency.in", prefix);
    r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_Emergency_in_not, comp_id,
                         "%s.PEv2.digin.Emergency.in-not", prefix);
    r |= hal_pin_bit_newf(HAL_IN, &inst->pev2_data.PEv2_digout_Emergency_out, comp_id,
                         "%s.PEv2.digout.Emergency.out", prefix);
    
    // Limit switch pins per axis
    for (int i = 0; i < 8; i++) {
        r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_LimitN_in[i], comp_id,
                             "%s.PEv2.%01d.digin.LimitN.in", prefix, i);
        r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_LimitN_in_not[i], comp_id,
                             "%s.PEv2.%01d.digin.LimitN.in-not", prefix, i);
        r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_LimitP_in[i], comp_id,
                             "%s.PEv2.%01d.digin.LimitP.in", prefix, i);
        r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_LimitP_in_not[i], comp_id,
                             "%s.PEv2.%01d.digin.LimitP.in-not", prefix, i);
        r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_Home_in[i], comp_id,
                             "%s.PEv2.%01d.digin.Home.in", prefix, i);
        r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_Home_in_not[i], comp_id,
                             "%s.PEv2.%01d.digin.Home.in-not", prefix, i);
        
        if (r != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Failed to export limit/home pins for axis %d\n", i);
            return r;
        }
    }
    
    // Homing pins
    for (int i = 0; i < 8; i++) {
        r |= hal_pin_u32_newf(HAL_IO, &inst->pev2_data.PEv2_HomingStatus[i], comp_id,
                             "%s.PEv2.%01d.HomingStatus", prefix, i);
        r |= hal_pin_bit_newf(HAL_IO, &inst->pev2_data.PEv2_index_enable[i], comp_id,
                             "%s.PEv2.%01d.index-enable", prefix, i);
        
        if (r != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Failed to export homing pins for axis %d\n", i);
            return r;
        }
    }
    
    // External outputs
    for (int i = 0; i < 4; i++) {
        r |= hal_pin_bit_newf(HAL_IN, &inst->pev2_data.PEv2_digout_ExternalRelay_out[i], comp_id,
                             "%s.PEv2.digout.ExternalRelay-%01d.out", prefix, i);
        r |= hal_pin_bit_newf(HAL_IN, &inst->pev2_data.PEv2_digout_ExternalOC_out[i], comp_id,
                             "%s.PEv2.digout.ExternalOC-%01d.out", prefix, i);
    }
    
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_ExternalRelayOutputs, comp_id,
                         "%s.PEv2.ExternalRelayOutputs", prefix);
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_ExternalOCOutputs, comp_id,
                         "%s.PEv2.ExternalOCOutputs", prefix);
    
    // Probing pins
    for (int i = 0; i < 8; i++) {
        r |= hal_pin_u32_newf(HAL_IO, &inst->pev2_data.PEv2_ProbePosition[i], comp_id,
                             "%s.PEv2.%01d.ProbePosition", prefix, i);
        r |= hal_pin_u32_newf(HAL_IO, &inst->pev2_data.PEv2_ProbeMaxPosition[i], comp_id,
                             "%s.PEv2.%01d.ProbeMaxPosition", prefix, i);
    }
    
    r |= hal_pin_u32_newf(HAL_OUT, &inst->pev2_data.PEv2_ProbeStatus, comp_id,
                         "%s.PEv2.ProbeStatus", prefix);
    r |= hal_pin_bit_newf(HAL_OUT, &inst->pev2_data.PEv2_digin_Probed_in, comp_id,
                         "%s.PEv2.digin.Probed.in", prefix);
    
    // MPG jogging pins
    for (int i = 0; i < 8; i++) {
        r |= hal_pin_bit_newf(HAL_IN, &inst->pev2_data.PEv2_joint_kb_jog_active[i], comp_id,
                             "%s.PEv2.%01d.joint-kb-jog-active", prefix, i);
        r |= hal_pin_bit_newf(HAL_IN, &inst->pev2_data.PEv2_joint_wheel_jog_active[i], comp_id,
                             "%s.PEv2.%01d.joint-wheel-jog-active", prefix, i);
    }
    
    if (r != 0) {
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Failed to export PEv2 HAL pins\n");
        return r;
    }
    
    // Initialize parameters with defaults
    for (int i = 0; i < 8; i++) {
        inst->pev2_data.PEv2_MaxSpeed[i] = 1000.0;
        inst->pev2_data.PEv2_MaxAcceleration[i] = 100.0;
        inst->pev2_data.PEv2_home_sequence[i] = -1;  // No homing by default
        inst->pev2_data.PEv2_stepgen_STEP_SCALE[i] = 1000.0;  // 1000 steps per unit
        inst->pev2_data.PEv2_PositionScale[i] = 1000;
        inst->pev2_data.PEv2_PositionOffset[i] = 0;
    }
    
    rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: PEv2 HAL pins exported successfully\n");
    return 0;
}


sPoKeysDevice * dev=0;
int i=0;
static char *serial_number = "";
static int ConnectionType = 0; // 1..USB, 2..UDP, 3..Network, 4..fastUSB
static char *IP = "0.0.0.0";
static int timeout_ms = 2000;
static int retry = 3;

sPoKeysDevice *TryConnectToDevice(uint32_t intSerial) {
    rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: serial_number: %d\n", intSerial);
    rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: serial_number=%d\n", __FILE__, __FUNCTION__, intSerial);
    sPoKeysDevice *retDev = NULL;
    uint32_t i_Timeout = 1000;
    uint32_t enm_usb_dev = 0;
    uint32_t enm_fusb_dev = 0;
    uint32_t enm_udp_dev = 0;
    int32_t nDevs = 0;
    uint32_t lastConectionTypeTried = 0;

    if (timeout_ms > 0) {
        i_Timeout = timeout_ms;
    }
    if (intSerial != 0) {
        retDev = PK_ConnectToDevice(0); // waits for usb device
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: intSerial=%d\n", __FILE__, __FUNCTION__, intSerial);
        if (retDev == NULL) {
            #ifndef RTAPI
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateUSBDevices\n", __FILE__, __FUNCTION__);
            enm_usb_dev = PK_EnumerateUSBDevices();
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: enm_usb_dev :%d\n", __FILE__, __FUNCTION__, enm_usb_dev);
            // enm_fusb_dev = PK_EnumerateFastUSBDevices();
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: enm_fusb_dev :%d\n", __FILE__, __FUNCTION__, enm_fusb_dev);
            #endif
            if (enm_usb_dev != 0 || enm_fusb_dev != 0) {
                rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d)\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
                #ifndef RTAPI
                retDev = PK_ConnectToDeviceWSerial((uint32_t)intSerial, i_Timeout); // waits for usb device
                #endif
                lastConectionTypeTried = 1;
                if (retDev == NULL) {
                    rtapi_print_msg(RTAPI_MSG_ERR,
                                    "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) "
                                    "FAILED\n",
                                    __FILE__, __FUNCTION__, intSerial, i_Timeout);
                                    #ifndef RTAPI   
                    retDev = PK_ConnectToDeviceWSerial((uint32_t)intSerial, i_Timeout); // waits for usb device
                    lastConectionTypeTried = 1;
                    #endif
                    if (retDev == NULL) {
                        rtapi_print_msg(RTAPI_MSG_ERR,
                                        "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) "
                                        "FAILED\n",
                                        __FILE__, __FUNCTION__, intSerial, i_Timeout);
#ifndef RTAPI
                        retDev = PK_ConnectToDeviceWSerial(intSerial, i_Timeout); // waits for usb device
                        #endif
                        lastConectionTypeTried = 1;
                        if (retDev == NULL) {
                            rtapi_print_msg(RTAPI_MSG_ERR,
                                            "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, "
                                            "%d) FAILED\n",
                                            __FILE__, __FUNCTION__, intSerial, i_Timeout);

                            retDev = PK_ConnectToDevice(0); // waits for usb device
                            lastConectionTypeTried = 1;
                            if (retDev == NULL) {
                                rtapi_print_msg(RTAPI_MSG_ERR,
                                                "PoKeys: %s:%s: PK_ConnectToDevice(0) "
                                                "FAILED\n",
                                                __FILE__, __FUNCTION__);

                                retDev = PK_ConnectToDevice(intSerial); // waits for usb device
                                lastConectionTypeTried = 1;
                                if (retDev == NULL) {
                                    rtapi_print_msg(RTAPI_MSG_ERR,
                                                    "PoKeys: %s:%s: PK_ConnectToDevice(%d) "
                                                    "FAILED\n",
                                                    __FILE__, __FUNCTION__, intSerial);
                                } else {
                                    rtapi_print_msg(RTAPI_MSG_ERR,
                                                    "PoKeys: %s:%s: PK_ConnectToDevice(%d) "
                                                    "OK\n",
                                                    __FILE__, __FUNCTION__, intSerial);
                                }

                            } else {
                                rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(0) OK\n", __FILE__, __FUNCTION__);
                            }
                        } else {
                            rtapi_print_msg(RTAPI_MSG_ERR,
                                            "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, "
                                            "%d) OK\n",
                                            __FILE__, __FUNCTION__, intSerial, i_Timeout);
                        }
                    } else {
                        rtapi_print_msg(RTAPI_MSG_ERR,
                                        "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) "
                                        "OK\n",
                                        __FILE__, __FUNCTION__, intSerial, i_Timeout);
                    }

                } else {
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) OK\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
                }
            }
        }
        if (retDev == NULL) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d)\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
            retDev = PK_ConnectToDeviceWSerial_UDP(intSerial, i_Timeout); // waits for udp device
            if (retDev == NULL) {
                rtapi_print_msg(RTAPI_MSG_ERR,
                                "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d) "
                                "FAILED\n",
                                __FILE__, __FUNCTION__, intSerial, i_Timeout);
            } else {
                rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d) OK\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
            }
            lastConectionTypeTried = 2;
            rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 2\n", __FILE__, __FUNCTION__);
        }
        if (retDev == NULL) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_SearchNetworkDevices(net_devices, %d, %d)\n", __FILE__, __FUNCTION__, i_Timeout, intSerial);
            sPoKeysNetworkDeviceSummary *net_devices;
            int32_t nDevs = PK_SearchNetworkDevices(net_devices, i_Timeout, intSerial);
            if (nDevs != 0) {
                enm_udp_dev = nDevs;
                rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices)\n", __FILE__, __FUNCTION__);
                retDev = PK_ConnectToNetworkDevice(net_devices);
                if (retDev == NULL) {
                    rtapi_print_msg(RTAPI_MSG_ERR,
                                    "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices) "
                                    "FAILED\n",
                                    __FILE__, __FUNCTION__);
                } else {
                    rtapi_print_msg(RTAPI_MSG_ERR,
                                    "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices) "
                                    "OK\n",
                                    __FILE__, __FUNCTION__);
                }
                lastConectionTypeTried = 3;
                rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
            } else {
                rtapi_print_msg(RTAPI_MSG_DBG,
                                "PoKeys: %s:%s: "
                                "PK_EnumerateNetworkDevices(net_devices, %d)\n",
                                __FILE__, __FUNCTION__, i_Timeout);
                //	nDevs = PK_EnumerateNetworkDevices(net_devices, i_Timeout); // does not work - it hangs here
                // deb_out = 1135;
                if (nDevs != 0) {
                    rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: nDevs: %s\n", __FILE__, __FUNCTION__, nDevs);
                    enm_udp_dev = nDevs;
                    rtapi_print_msg(RTAPI_MSG_DBG,
                                    "PoKeys: %s:%s: "
                                    "PK_ConnectToNetworkDevice(net_devices)\n",
                                    __FILE__, __FUNCTION__);
                    retDev = PK_ConnectToNetworkDevice(net_devices);
                    lastConectionTypeTried = 3;
                    rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
                }
            }
        }
    } else {
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: udp_devices[16]\n", __FILE__, __FUNCTION__);
        sPoKeysNetworkDeviceSummary udp_devices[16];
#ifndef RTAPI
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateUSBDevices()\n", __FILE__, __FUNCTION__);
        enm_usb_dev = PK_EnumerateUSBDevices();
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateUSBDevices()=%d\n", __FILE__, __FUNCTION__, enm_usb_dev);

        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateFastUSBDevices()\n", __FILE__, __FUNCTION__);
        // enm_fusb_dev = PK_EnumerateFastUSBDevices();
        // rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateFastUSBDevices()=%d\n", __FILE__, __FUNCTION__, enm_fusb_dev);
 #endif
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateNetworkDevices(udp_devices, %d)\n", __FILE__, __FUNCTION__, i_Timeout);
        int32_t nDevs = PK_EnumerateNetworkDevices(udp_devices, i_Timeout); // does not work - it hangs here
        //	rtapi_print("");
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: nDevs: %d\n", __FILE__, __FUNCTION__, nDevs);
        // enm_udp_dev = nDevs;

        if (nDevs != 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(udp_devices) - %d\n", __FILE__, __FUNCTION__, nDevs);
            for (int i = 0; i < 16; i++) {
                if (retDev == NULL) {
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: udp_devices[%d].SerialNumber: %d\n", __FILE__, __FUNCTION__, i, udp_devices[i].SerialNumber);
                    if (udp_devices[i].SerialNumber != 0) {
                        rtapi_print_msg(RTAPI_MSG_ERR,
                                        "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, "
                                        "%d)\n",
                                        __FILE__, __FUNCTION__, udp_devices[i].SerialNumber, i_Timeout);
                        retDev = PK_ConnectToDeviceWSerial_UDP(udp_devices[i].SerialNumber,
                                                               i_Timeout); // waits for udp device
                        lastConectionTypeTried = 2;
                        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: lastConectionTypeTried = 2\n", __FILE__, __FUNCTION__);
                    }
                } else {
                    break;
                }
            }
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
        }
        if (enm_fusb_dev > 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice FastUSB\n", __FILE__, __FUNCTION__);
            for (int i = 0; i < enm_fusb_dev + 1; i++) {
                rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d)\n", __FILE__, __FUNCTION__, i);
                retDev = PK_ConnectToDevice(i);
                if (retDev == NULL) {
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) FAILED\n", __FILE__, __FUNCTION__, i);
                } else {
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) OK\n", __FILE__, __FUNCTION__, i);
                }
            }
            lastConectionTypeTried = 4;
        }

        if (enm_usb_dev > 0) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice USB\n", __FILE__, __FUNCTION__);
            for (int i = 0; i < enm_usb_dev + 1; i++) {
                rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d)\n", __FILE__, __FUNCTION__, i);
                retDev = PK_ConnectToDevice(i);
                if (retDev == NULL) {
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) FAILED\n", __FILE__, __FUNCTION__, i);
                } else {
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) OK\n", __FILE__, __FUNCTION__, i);
                }
            }
            lastConectionTypeTried = 4;
        }
        // deb_out = 120;
    }
    if (retDev != NULL) {
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: Connected to device\n", __FILE__, __FUNCTION__);
        // connected = 1;
        if (lastConectionTypeTried == 1) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: USB\n", __FILE__, __FUNCTION__);
        }
        if (lastConectionTypeTried == 2) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: UDP\n", __FILE__, __FUNCTION__);
        }
        if (lastConectionTypeTried == 3) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: Network\n", __FILE__, __FUNCTION__);
        }
        return retDev;
    } else {
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: failed to connect to device\n", __FILE__, __FUNCTION__);
        return NULL;
    }
}

#ifndef RTAPI
void user_mainloop(void) 
{ 

   int RTC_count =10;
   int RTC_Trig = 10;
    #ifndef RTAPI
    while(0xb){
       FOR_ALL_INSTS() {

           // while(dev == NULL)dev = PK_ConnectToDeviceWSerial(devSerial, 2000);  //waits for usb device
            

          //  alive=1; 
            if(RTC_count>=RTC_Trig){
                rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_RTCGetAsync\n", __FILE__, __FUNCTION__);
                if (PK_RTCGetAsync(__comp_inst->dev)==0){
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_RTCGetAsync OK\n", __FILE__, __FUNCTION__);
                    RTC_count = 0;
                }
                else if (PK_RTCGet(__comp_inst->dev)==PK_OK){
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_RTCGet OK\n", __FILE__, __FUNCTION__);
                    RTC_count = 0;
                }
                else{
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_RTCGet FAILED\n", __FILE__, __FUNCTION__);
                }
            }
            else{
                RTC_count++;
            }

            if(PK_EncoderValuesGetAsync(__comp_inst->dev) == PK_OK) {
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EncoderValuesGetAsync OK\n", __FILE__, __FUNCTION__);
                } else {
                    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EncoderValuesGetAsync FAILED\n", __FILE__, __FUNCTION__);
                }

            PK_ReceiveAndDispatch(__comp_inst->dev); // checks for timeout and retry
            PK_TimeoutAndRetryCheck(__comp_inst->dev, 6000); // checks for timeout and retry

            alive=0;
            usleep(100); 
        
        }
    }
    #endif
    exit(0);
}
#endif

#ifdef RTAPI
// RT-safe motion command processing functions
static void rt_read_command_pins(struct __comp_state *inst) {
    for (int i = 0; i < 8; i++) {
        float new_pos = *(inst->pev2_data.joint_pos_cmd[i]);
        float new_vel = *(inst->pev2_data.joint_vel_cmd[i]);
        
        // Check for command changes
        if (new_pos != motion_data.pos_cmd[i] || new_vel != motion_data.vel_cmd[i]) {
            motion_data.pos_cmd[i] = new_pos;
            motion_data.vel_cmd[i] = new_vel;
            motion_data.pos_cmd_changed[i] = true;
        }
    }
}

static void rt_update_motion_commands(struct __comp_state *inst) {
    uint8_t changed_axis_mask = 0;
    float positions[8], velocities[8];
    
    for (int i = 0; i < 8; i++) {
        if (motion_data.pos_cmd_changed[i]) {
            changed_axis_mask |= (1 << i);
            // Convert to device units using scale
            positions[i] = motion_data.pos_cmd[i] * inst->pev2_data.PEv2_stepgen_STEP_SCALE[i];
            velocities[i] = motion_data.vel_cmd[i] / inst->pev2_data.PEv2_MaxSpeed[i];
            motion_data.pos_cmd_changed[i] = false;
        }
    }
    
    // Queue MovePV command for changed axes
    if (changed_axis_mask != 0) {
        queue_move_pv_command(changed_axis_mask, positions, velocities);
    }
}

static void rt_read_device_cache(struct __comp_state *inst) {
    // Only update if cache is valid and recent
    if (!device_cache.communication_ok) {
        return;
    }
    
    // Update feedback from cached device data (populated by async thread)
    for (int i = 0; i < 8; i++) {
        // Position feedback with scaling  
        float pos_fb = (float)device_cache.current_position[i] / inst->pev2_data.PEv2_stepgen_STEP_SCALE[i];
        *(inst->pev2_data.joint_pos_fb[i]) = pos_fb;
        motion_data.pos_fb[i] = pos_fb;
        
        // In-position status (within deadband)
        float pos_error = fabs(motion_data.pos_cmd[i] - pos_fb);
        bool in_position = (pos_error < 0.01); // 0.01 unit deadband
        *(inst->pev2_data.joint_in_position[i]) = in_position;
        motion_data.in_position[i] = in_position;
        
        // Update axis state
        *(inst->pev2_data.PEv2_AxesState[i]) = device_cache.axes_state[i];
        *(inst->pev2_data.PEv2_CurrentPosition[i]) = device_cache.current_position[i];
    }
    
    // Update device info
    *(inst->pev2_data.PEv2_PulseEngineState) = device_cache.pulse_engine_state;
    
    // Update limit switches
    for (int i = 0; i < 8; i++) {
        bool limit_n = (device_cache.limit_status_n & (1 << i)) != 0;
        bool limit_p = (device_cache.limit_status_p & (1 << i)) != 0;
        bool home = (device_cache.home_status & (1 << i)) != 0;
        
        *(inst->pev2_data.PEv2_digin_LimitN_in[i]) = limit_n;
        *(inst->pev2_data.PEv2_digin_LimitN_in_not[i]) = !limit_n;
        *(inst->pev2_data.PEv2_digin_LimitP_in[i]) = limit_p;
        *(inst->pev2_data.PEv2_digin_LimitP_in_not[i]) = !limit_p;
        *(inst->pev2_data.PEv2_digin_Home_in[i]) = home;
        *(inst->pev2_data.PEv2_digin_Home_in_not[i]) = !home;
    }
    
    // Update emergency status
    *(inst->pev2_data.PEv2_digin_Emergency_in) = device_cache.emergency_active;
    *(inst->pev2_data.PEv2_digin_Emergency_in_not) = !device_cache.emergency_active;
}

static void rt_handle_homing_commands(struct __comp_state *inst) {
    // Check for homing sequence requests
    static uint32_t last_homing_status[8] = {0};
    uint32_t homing_mask = 0;
    
    for (int i = 0; i < 8; i++) {
        uint32_t current_status = *(inst->pev2_data.PEv2_HomingStatus[i]);
        
        // Detect homing start request (rising edge)
        if (current_status != 0 && last_homing_status[i] == 0) {
            homing_mask |= (1 << i);
        }
        last_homing_status[i] = current_status;
    }
    
    if (homing_mask != 0) {
        queue_homing_start_command(homing_mask);
    }
}

static void rt_update_external_outputs(struct __comp_state *inst) {
    // Check for external output changes
    static bool last_relay_outputs[4] = {false};
    static bool last_oc_outputs[4] = {false};
    bool outputs_changed = false;
    
    uint8_t relay_mask = 0, oc_mask = 0;
    
    for (int i = 0; i < 4; i++) {
        bool relay_out = *(inst->pev2_data.PEv2_digout_ExternalRelay_out[i]);
        bool oc_out = *(inst->pev2_data.PEv2_digout_ExternalOC_out[i]);
        
        if (relay_out != last_relay_outputs[i]) {
            outputs_changed = true;
            last_relay_outputs[i] = relay_out;
        }
        
        if (oc_out != last_oc_outputs[i]) {
            outputs_changed = true;
            last_oc_outputs[i] = oc_out;
        }
        
        if (relay_out) relay_mask |= (1 << i);
        if (oc_out) oc_mask |= (1 << i);
    }
    
    if (outputs_changed) {
        // Update device structure for async thread
        inst->dev->PEv2.ExternalRelayOutputs = relay_mask;
        inst->dev->PEv2.ExternalOCOutputs = oc_mask;
        
        // Queue async command
        async_command_t cmd = {
            .type = CMD_EXTERNAL_OUTPUT_SET,
            .axis_mask = 0,
            .misc_data = (relay_mask << 8) | oc_mask
        };
        enqueue_async_command(&cmd);
    }
    
    // Update feedback pins
    *(inst->pev2_data.PEv2_ExternalRelayOutputs) = relay_mask;
    *(inst->pev2_data.PEv2_ExternalOCOutputs) = oc_mask;
}

FUNCTION(_) {
    if (__comp_inst == 0) return;
    
    int64_t start_time = rtapi_get_time();
    
    // Process communication with device
    PK_ReceiveAndDispatch(__comp_inst->dev);
    PK_TimeoutAndRetryCheck(__comp_inst->dev, 1000);
    
    // 1. Read HAL command pins and detect changes
    rt_read_command_pins(__comp_inst);
    
    // 2. Update cached device data from async responses
    rt_read_device_cache(__comp_inst);
    
    // 3. Process motion commands and queue async operations
    rt_update_motion_commands(__comp_inst);
    
    // 4. Handle homing sequence commands
    rt_handle_homing_commands(__comp_inst);
    
    // 5. Update external outputs if changed
    rt_update_external_outputs(__comp_inst);
    
    // 6. Process async commands (limited per cycle to maintain RT performance)
    if (async_processing_enabled) {
        process_async_commands(__comp_inst);
        update_device_cache(__comp_inst);
    }
    
    // Legacy IO operations (maintain existing behavior)
    if (PK_RTCGetAsync(__comp_inst->dev) == PK_OK) {
        PK_ReceiveAndDispatch(__comp_inst->dev);
    }
    
    if (PK_EncoderValuesGetAsync(__comp_inst->dev) == PK_OK) {
        PK_ReceiveAndDispatch(__comp_inst->dev);
    }
    
    if (PK_DigitalIOSetGetAsync(__comp_inst->dev) == PK_OK) {
        PK_ReceiveAndDispatch(__comp_inst->dev);
    }
    
    if (PK_DigitalIOGetAsync(__comp_inst->dev) == PK_OK) {
        PK_ReceiveAndDispatch(__comp_inst->dev);
    }
    
    if (PK_DigitalIOSetAsync(__comp_inst->dev) == PK_OK) {
        PK_ReceiveAndDispatch(__comp_inst->dev);
    }
    
    if (PK_PWMUpdateAsync(__comp_inst->dev) == PK_OK) {
        PK_ReceiveAndDispatch(__comp_inst->dev);
    }
    
    if (PK_AnalogIOGetAsync(__comp_inst->dev) == PK_OK) {
        PK_ReceiveAndDispatch(__comp_inst->dev);
    }
    
    // Final communication processing
    PK_ReceiveAndDispatch(__comp_inst->dev);
    PK_TimeoutAndRetryCheck(__comp_inst->dev, 1000);
    
    int64_t end_time = rtapi_get_time();
    if ((end_time - start_time) > 5000000) { // Only log if > 5ms
        rtapi_print_msg(RTAPI_MSG_WARN, "PoKeys RT: Long cycle time: %lld ns\n", 
                       end_time - start_time);
    }
}
#endif

static int __comp_get_data_size(void) { return 0; }



EXTRA_SETUP() {
    int wait_ms = 5000;
    const char *ini_path = getenv("INI_FILE_NAME");
    FILE *fp = fopen(ini_path, "r");
    if (fp) {
    //    iniFindInt(fp, "DEVICE_ID", "POKEYS", &device_id);
    //    iniFindInt(fp, "COMM_TIMEOUT", "POKEYS", &timeout_ms);

        // ApplyIniSettings
        int tmpIniSettings = 0;
    //    iniFindInt(fp, "ApplyIniSettings", "POKEYS", &tmpIniSettings);

        if (tmpIniSettings != 0) {
    //        ApplyIniSettings = true;
        }
    }

    rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: extra_arg=%s device_id=%i \n", __FILE__, __FUNCTION__, extra_arg, device_id);

    // usleep(wait_ms);  // wait for the HAL to start up
    for (i = 0; i < retry; i++) {
        if (__comp_inst->dev == NULL) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: TryConnectToDevice(0)\n", __FILE__, __FUNCTION__);
            __comp_inst->dev = TryConnectToDevice(device_id);
        }
        if (__comp_inst->dev != NULL) {
            rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: Connected\n", __FILE__, __FUNCTION__);
            break;
        }
    }

    if (__comp_inst->dev == NULL) {
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: could not connect to device\n", __FILE__, __FUNCTION__);
        return -1;
    }
    
    // Start async processing
    if (start_async_processing(__comp_inst) != 0) {
        rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: failed to start async processing\n", __FILE__, __FUNCTION__);
        return -1;
    }
    
    //	PKEncoder_init(comp_id, dev);
    rtapi_print("");
    // devSerial = extra_arg;
    return 0;
}

// ========================================
// PHASE 2: ASYNC COMMUNICATION THREAD
// ========================================

// Forward declarations for Phase 2 functions
static void process_async_commands(struct __comp_state *inst);
static void update_device_cache(struct __comp_state *inst);
static int start_async_processing(struct __comp_state *inst);
static void stop_async_processing(void);

// Async processing function (called from RT thread periodically)
static void process_async_commands(struct __comp_state *inst) {
    async_command_t cmd;
    int commands_processed = 0;
    const int MAX_COMMANDS_PER_CYCLE = 3; // Limit to prevent RT overrun
    
    // Process queued commands (limited per cycle)
    while (commands_processed < MAX_COMMANDS_PER_CYCLE && dequeue_async_command(&cmd)) {
        commands_processed++;
        
        switch (cmd.type) {
            case CMD_MOVE_PV: {
                // Update device structure with new position/velocity commands
                for (int i = 0; i < 8; i++) {
                    if (cmd.axis_mask & (1 << i)) {
                        inst->dev->PEv2.ReferencePositionSpeed[i] = (int32_t)cmd.pos_values[i];
                        inst->dev->PEv2.ReferenceVelocityPV[i] = cmd.vel_values[i];
                    }
                }
                inst->dev->PEv2.param2 = cmd.axis_mask;
                
                // Send MovePV command
                PK_PEv2_PulseEngineMovePVAsync(inst->dev);
                break;
            }
            
            case CMD_HOME_START: {
                inst->dev->PEv2.param2 = cmd.axis_mask;
                PK_PEv2_HomingStartAsync(inst->dev);
                break;
            }
            
            case CMD_EXTERNAL_OUTPUT_SET: {
                inst->dev->PEv2.ExternalRelayOutputs = (cmd.misc_data >> 8) & 0xFF;
                inst->dev->PEv2.ExternalOCOutputs = cmd.misc_data & 0xFF;
                PK_PEv2_ExternalOutputsSetAsync(inst->dev);
                break;
            }
        }
    }
}

static void update_device_cache(struct __comp_state *inst) {
    static int64_t last_status_update = 0;
    int64_t current_time = rtapi_get_time();
    const int64_t STATUS_UPDATE_INTERVAL = 10000000LL; // 10ms in nanoseconds
    
    // Periodic device status updates
    if ((current_time - last_status_update) > STATUS_UPDATE_INTERVAL) {
        // Request PEv2 status update
        PK_PEv2_StatusGetAsync(inst->dev);
        last_status_update = current_time;
        
        // Update cache with current device data
        device_cache.pulse_engine_state = inst->dev->PEv2.PulseEngineState;
        device_cache.limit_status_p = inst->dev->PEv2.LimitStatusP;
        device_cache.limit_status_n = inst->dev->PEv2.LimitStatusN;
        device_cache.home_status = inst->dev->PEv2.HomeStatus;
        device_cache.emergency_active = (inst->dev->PEv2.ErrorInputStatus & 0x01) != 0;
        
        for (int i = 0; i < 8; i++) {
            device_cache.axes_state[i] = inst->dev->PEv2.AxesState[i];
            device_cache.current_position[i] = inst->dev->PEv2.CurrentPosition[i];
        }
        
        // Mark cache as valid and updated
        device_cache.last_update_time = current_time;
        device_cache.communication_ok = true;
    }
}

// Processing control functions
static int start_async_processing(struct __comp_state *inst) {
    // Initialize device cache
    device_cache.communication_ok = false;
    device_cache.last_update_time = 0;
    
    async_processing_enabled = true;
    
    rtapi_print_msg(RTAPI_MSG_INFO, "PoKeys: Async processing enabled\n");
    return 0;
}

static void stop_async_processing(void) {
    async_processing_enabled = false;
    rtapi_print_msg(RTAPI_MSG_INFO, "PoKeys: Async processing disabled\n");
}

EXTRA_CLEANUP() {
    // Stop the async processing
    stop_async_processing();
    
    rtapi_print_msg(RTAPI_MSG_INFO, "PoKeys: Component cleanup completed\n");
}

#ifdef RTAPI
//hal_export_funct("pokeys_async.funct", FUNCTION, inst, 0, 0, comp_id);
#endif